# rvos 编写经验

在启动过程完成之后，已经进入多线程，在main函数里面 试试print,会发现直接出现了三个 hello rvos。，每个线程发送一个，但是每次运行打印的顺序完全不同。 这个时候我们就需要用到锁了。

我们需要给print整个代码上锁，让它在一次打印中不会被中断，这样就能正常打印了。

锁利用的是编译器自带的指令。记得在用锁时需要关闭中断。锁里面保存一个cpu的结构体是为了方便管理关中断的深度。

当最基础的锁有了之后，感觉可以开始考虑内存的问题了。下一步装载页表和内存分配。

这里有一个问题

```c
int i =0 ;

for(i =0; i<100;i++ ){
    j =i+j
}
print("%d \n", i);
```

这段代码，我对i 加锁之后会出现bug 以我现在的水平 我并不知道问题处在哪儿， 我猜是需要对同步原语有一定了解才行。

---

忘了切换分支 以下都在kalloctest的分支里面。

接下来是trap和中断处理

首先要了解riscv的特权指令

在riscv中 ，M-mode 下运行期间可能发生的异常有五种

「访问错误异常 ： 当物理地址不支持访问时发生」

「断点异常 ：ebreak时，或者数据与调试触发器匹配时发生」

「环境调用异常：ecall时发生」

「非法指令异常：译码阶段的无效指令」

「非对齐指令异常 ：在有效地址不能被访问大小整除时发生，例如地址为 0x12 的amoadd.w 」debug： 不是很明白这个

M-mode下的8个控制状态寄存器

「mtvec （machine trap vector）： 发生异常的时候处理器需要跳转的位置」

「mepc （machine exception pc）」 ： 指向发生异常时的指令

「macuse (machine exception cause)」:发生异常的种类

「mie （machine interrpt enbale）」：指出能处理和必须忽略的中断

「mip（machine interrupt pending）」：目前准备处理的中断

「mtval （machine trap value）」：保存了陷入的附加信息（发生地址，出错指令本身，）

「mscratch （machine scratch）」：能保存一个字的数据

「mstatus（machine status）」：

当一个hart发生中断的时候：

    具有异常指令的pc被保存在mepc,pc被设置为mtvec

    根据异常来源设置macuse

    mie置0禁用中断

    发生异常的权限模式保存在mstatus中

根据以上我们可以简单的写出一个处理异常的程序

由于我们是在s模式下运行，所以以上开头换成s就行了。

首先在kernelvec中保存寄存器，然后跳转到kerneltrap 在kerneltrap中处理完异常后通过sret回到之前的位置，记得此时mepc需要+4 debug：在我debug的过程中，+4不行 需要+2？？这是为什么暂时不清楚。（好像是因为开启了压缩指令集 导致了每条指令不是精准的 +4）。

现在我们要设置时钟中断。设置时钟中断在opensbi里面显得极为简单 只需要调用opensbii的接口就行了。

---

分页

此时采用的是riscv64 的sv39分页模式

只使用虚拟地址的低39位，高25位不使用

riscv页表是由一个2^27个页表条目组成的数组

页表用的是三级页表，

在分页的时候有三个 512个条目

一共有512 *512 * 512 也就是2^27个条目 有这么多个页

每个页是4KB

于是我们在找真实地址的时候就可以用 页表及地址+offset的方式

同时我门需要把虚拟地址映射到真实的物理地址上。此时我们使用的是直接映射。

在我们的操作系统里面 为了简单 直接设置一个地址能用的空间就是一个页。

找到一个地址就会变得很简单，直接找到那个页就行。

在映射的最开始，根pagetable里面什么都没有，然后walk先找到根页表，如果此位置是没有被映射即为初始值0的时候，那么先申请一个页，将此位置的值改为申请的页。（虚拟地址和实际地址的映射是根据 PA2PTE 和PTE2PA 这两个宏定义确定的）。找到一级页表也是一样的，最后返回的时候是2及页表也就是最后一个页表，这个页表里面存的地址是指向的买个内存页。然后在mappages里面进行映射。

映射完成时我们就有一个可以使用的页表了。